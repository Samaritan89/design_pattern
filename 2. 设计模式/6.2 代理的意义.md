# 代理的意义

也许大家会有疑问，不过实现一个小小的图片预加载功能，即使不引入任何模式也能办到，那么引入代理模式的好处究竟在哪里？我们写一个不用代理的函数实现

    var myInmage = (function(){
        
        var imgNode = document.createElement('img');
        document.body.appendChild(imgNode);
        
        var img = new Image();
        img.onload = function(){
            imgNode.src = img.src;
        };

        return {
            setSrc: function(src){
                imageNode.src = 'loading.gif';
                img.src = src;
            }
        };

    })();

为了说明代理模式的意义，介绍一下一个面向对象设计的原则——单一职责原则

单一职责原则指的是，就一个类(通常叶包括对象和函数)而言，应该仅有一个引起它变化的原因。如果一个对象承担了多项职责，就意味着这个对象将变得巨大，引起它变化的原因将有多个。

面向对象设计鼓励将行为分布到细粒度的对象中，如果一个对象承担的职责过多，等于把这些职责耦合到了一起，这种耦合会导致脆弱和低内聚的设计，当变化发生时，设计可能会早到意外的破坏。

职责被定义为“引起变化的原因”，上段代码中myImage对象除了负责给image设置src，还要负责预加载图片。我们在处理其中一个职责的时候，很有可能因为其强耦合性影响另外一个职责实现。

另外在面向对象程序设计中，大多数情况下，若违反其它任何原则，同时也会违反开放-封闭原则。如果我们只是从网络上获取其它一些很小的图片，我们希望把预加载功能移除，这时候就不得不改动myImage对象了。

实际上我们需要的只是给img节点设置src属性，预加载图片只是一个锦上添花的功能，如果能把这个操作放在另外一个对象里，自然是一个非常好的方法。于是代理的作用在这里就体现出来了，代理负责预加载图片，预加载完成之后，把请求重新交给本体myImage。

纵观整个程序，我们并没有改变或者增加myimage接口，但是通过代理对象，实际上给系统添加了新的行为。这是符合开放-封闭原则的。

给img设置src和图片预加载这两个重要功能被隔绝在两个对象里，它们可以相互变化而不影响对方。

## 代理和本体接口的一致性

上面提到如果我们不在需要预加载，那么就不在需要代理对象，可以选择直接请求本体，其中一个关键是代理和本体都对外提供了setSrc方法，在客户看来代理对象和本体对象是一致的，代理接手请求的过程对于用户来说是透明的，用户并不清楚代理和本体的区别，这样做有两个好处

1. 用户可以放心的请求代理，他只关心是否能得到想要的结果。
2. 在任何使用本体的地方都可以替换成使用代理

在Java中代理和本体都需要显示的实现同一个接口，一方面接口保证了它们会拥有同样的方法，另一方面面向接口编程迎合依赖导致原则，通过接口进行向上转型。

在JavaScript这类动态语言中，我们有时通过鸭子类型来检测代理和本体是否都实现了`setSrc`方法，另外大多是时候甚至不做检测，全部依赖自觉，这对程序健壮性是有影响的。如果代理对象和本体对象都是一个函数，函数必然能够被执行，则可以认为它们有一致的接口。
