# JavaScript中的单例模式

前面提到的几种单例模式的实现，更多的是接近传统面向对象语言中的实现，单例对象从“类”中创建而来。在以类为中心的语言中，这是很自然的做法。比如在Java中，如果需要某个对象，就必须先定义一个类，对象总是从类中创建而来。

但JavaScript其实是一门无类(class-free)语言，正是因为此，生硬的移植单例模式的概念意义不大。在JavaScript中创建对象的方法非常简单，既然我们只需要一个“唯一”的对象，为什么要先为它创建一个类呢？

单例模式的核心是*确保只有一个实例，并且提供全局访问*

全局变量不是单例模式，但在JavaScript开发中，我们经常把全局变量当做单例开始用

    var a = {};

当用这种方式创建对象`a`时，对象是独一无二的。如果变量被声明在全局作用域下，我们可以在代码中的任何位置使用这个变量，全局变量提供给全局访问是理所当然的，这样就满足了单例模式的两个条件。

但是全局变量存在很多问题，他很容易造成命名空间污染，在大型项目中如果不加以限制和管理，程序中可能存在很多这样的变量。JavaScript的变量叶很容易被不小心覆盖。

Douglas Crockford多次把全局变量称为JavaScript最糟糕的特性。作为普通开发者我们有必要减少全局变量的使用，即时需要也要把他的污染降到最低。

## 使用命名空间

适当的使用命名空间并不会杜绝全局变量，但可以减少全局变量的数量。

最简单的方法依然是用对象字面量方式

    var namespace1 = {
        a: function(){},
        b: function(){}
    };

## 使用闭包封存私有变量

这种方法把一些变量封装在闭包内部，只暴露一些接口和外界通信

    var users = (function(){
        var _name = 'Test',
            _age = 20;

        return {
            getUserInfo: function(){
                return _name + '-' + _age;
            }
        };
    })();
